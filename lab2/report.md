# Determinism in Finite Automata. Conversion from NDFA 2 DFA. Chomsky Hierarchy.

## Theory
### Type 0 Grammar
Type-0 grammars include all formal grammar. Type 0 grammar languages are recognized by turing machine. These languages are also known as the Recursively Enumerable languages. 

Grammar Production in the form of   
`α→β`  where 
```
α is ( V + T)* V ( V + T)*
V : Variables
T : Terminals. 
β is ( V + T )*. 
```

In type 0 there must be at least one variable on the Left side of production

### Type 1 Grammar
Type-1 grammars generate context-sensitive languages. The language generated by the grammar is recognized by the Linear Bound Automata 

In Type 1 should be of Type 0 and in the form of
```
α→β
∣α∣≤∣β∣
```
That is the count of symbol in α is less than or equal to β

### Type 2 Grammar
Type-2 grammars generate context-free languages. The language generated by the grammar is recognized by a Pushdown automata. In Type 2, it should be Type 1 and the left-hand side of production can have only one variable and there is no restriction on β

`∣α∣=1`

### Type 3 Grammar
Type-3 grammars generate regular languages. These languages are exactly all languages that can be accepted by a finite-state automaton. Type 3 is the most restricted form of grammar. 

Type 3 should be in the given form only:

```
V --> VT / T          (left-regular grammar)
(or)
V --> TV /T          (right-regular grammar)
```


## Task
1. Understand what an automaton is and what it can be used for.
2. Continuing the work in the same repository and the same project, the following need to be added:

    a. Provide a function in your grammar type/class that could classify the grammar based on Chomsky hierarchy.

    b. For this you can use the variant from the previous lab.
3. According to your variant number (by universal convention it is register ID), get the finite automaton definition and do the following tasks: 

    a. Implement conversion of a finite automaton to a regular grammar.

    b. Determine whether your FA is deterministic or non-deterministic.

    c. Implement some functionality that would convert an NDFA to a DFA.

    d. Represent the finite automaton graphically

Below is the grammar that is to be developed for variant 32:
```
Q = {q0,q1,q2},
∑ = {a,b,c},
F = {q2},
δ(q0,a) = q0,
δ(q0,a) = q1,
δ(q1,c) = q0,
δ(q1,b) = q1,
δ(q1,a) = q2,
δ(q2,a) = q2.
```

## Implementation
### Chomsky Hierarchy Classification


### FA To Grammar

```python

```

### Determinism Identificator for FA

```python

```

### Visualize Graph

```python

```


### Implementation showcase
Firstly, the main of the project will convert the grammar rules into a DFA. The converted propertes will be printed. Moreover, the `is_deterministic` function will be called to make sure that it works correctly. All this data will be outputted to the screen, which can be seen in the first screenshot.

Secondly, the program converts the DFA info NFA. Similar properties will be printed to the console. This time, program will make sure that NFA is not deterministic. 
![Program Output](./images/image3.png)

Below are the graphs of the FAs generated using the program. It can be tracked using the corresponding rules that the graphs are indeed correct. 
![Graph 1](./images/image1.png)
![Graph 2](./images/image2.png)

## Conclusion


## References
[Chomsky Hierarchy of Computation](https://www.geeksforgeeks.org/chomsky-hierarchy-in-theory-of-computation/)